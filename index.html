<html>

<head>
    <meta charset="UTF-8">
    <title>Tampopo project</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/marx-css/css/marx.min.css">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <main>
        <section>
            <h1>Character Connections in Tampopo</h1>
            <article>
                Tampopo is a film with a multitude of characters, both in the main story and the many
                vignettes. This graph attempts to capture the structure of Tampopo and display it in a
                way that encourages the development of new understandings of the film.
            </article>
            <article>
                Hopefully you will be able to learn things and take away something from this graph that
                was not immediately clear from a simple linear viewing of the film.
            </article>

            <h3>Characters connected by physical space</h3>
            <article>
                Each node represents a character, and characters are connected with an edge if they appear in
                the same shot at least once during the runtime of the film. They are considered to appear in the
                same shot if they are either both visible on screen in a shot, or if they are implied to be in the
                same shot even if one or both are not visible (such as if one is in a car in the background).
            </article>
        </section>
    </main>
    <div class="center">
        <svg id="network" height="500" width="1200"></svg>
    </div>
    <main>
        <section>
            <h3>Characters connected by sharing meals</h3>
        </section>
    </main>
    <div id="chord-container">
        <svg id="chord" height="600" width="1000"></svg>
    </div>
    <div id="button-container">
        <button id="ramen">Ramen color scheme</button>
        <button id="normal">Normal color scheme</button>
    </div>

    <script>
        // heavily inspired by Jeff R's INFO 3300 Fall 2021 notes
        const svg = d3.select('#network');
        const networkLayer = svg.append('g');
        const chartWidth = svg.attr('width');
        const chartHeight = svg.attr('height');

        const createGraphs = async function () {
            const appearances = await d3.csv("./data/appearances.csv");
            const nodes = await d3.csv("./data/characters.csv");
            let appearancesMatrix = [];

            // convert to 2d array and parse ints
            for (let i = 0; i < nodes.length; i++) {
                nodes[i]['id'] = parseInt(nodes[i]['id']);
                let curr = appearances[i];
                let row = [];
                for (let j = 0; j < nodes.length; j++) {
                    row.push(parseInt(curr[j]));
                }
                appearancesMatrix.push(row);
            }

            console.log(appearancesMatrix);
            console.log(nodes);

            let links = [];

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i; j < nodes.length; j++) {
                    if (appearancesMatrix[i][j] === 1 && i !== j) {
                        sourceID = nodes[i]['id'];
                        targetID = nodes[j]['id'];
                        link = { 'source': sourceID, 'target': targetID };
                        links.push(link);
                    }
                }
            }
            console.log(links);


            let sim = d3.forceSimulation()
                .nodes(nodes)
                .force('links', d3.forceLink().links(links).id(d => d['id'])) // force keeping nodes linked together close
                .force('repulse', d3.forceManyBody().strength(-60)) // repulsion between all nodes to space them apart
                .force('center', d3.forceCenter(chartWidth / 2., chartHeight / 2.)) // keep the whole network centered
                .on('tick', render);

            function stringLen(str) {
                const dummytext = networkLayer.append("text").attr("class", "legendtext").attr("visibility", "hidden");
                dummytext.text(str)
                let len = dummytext.node().getComputedTextLength()
                dummytext.remove()
                return len;
            }

            // TODO:
            // - is it better for the tags and nodes to go above info box or below it?
            // make the nodes and lines bigger?
            // - write explanation of the graph above
            // - check connections to see if they make sense
            // - remove some characters?
            function render() {
                // draw edges
                let lines = networkLayer.selectAll('line.link').data(links)
                    .join(
                        enter => enter.append('line').attr('class', 'link').attr('stroke', 'black')
                    )
                    .attr('x1', d => d.source.x)
                    .attr('x2', d => d.target.x)
                    .attr('y1', d => d.source.y)
                    .attr('y2', d => d.target.y);

                // draw nodes
                let circles = networkLayer.selectAll('circle.node').data(nodes)
                    .join(
                        enter => enter.append('circle')
                            .attr('class', 'node')
                            .attr('stroke', 'black')
                            .attr('r', 10)
                            .attr('cx', 0)
                            .attr('cy', 0)
                            .attr('fill', d => d.id === 0 ? 'sienna' : 'white')
                            .on('mouseover', handleHover)
                            .on('mousemove', handleHover)
                            .on('mouseout', handleMouseOut)
                            .call(d3.drag().on('start', dragStart).on('drag', dragging).on('end', dragend))

                    )
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);

            }

            render();

            let connectionInfo = svg.append('g')
                .attr('class', 'connection-info')
                .attr('transform', `translate(800,60)`)
                .attr('visibility', 'hidden');

            let frameShadow = connectionInfo
                .append('rect')
                .attr('class', 'connection-shadow')
                .attr('x', 2)
                .attr('y', 2)
                .attr('height', 0)
                .attr('width', 0)
                .attr('color', 'white')
                .attr('stroke', 'black')
                .attr('stroke-width', 4)
                .attr('rx', 5)
                .attr('ry', 5);

            let connectionFrame = connectionInfo
                .append('rect')
                .attr('class', 'connection-frame')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', 0)
                .attr('width', 0)
                .attr('color', 'tomato')
                .attr('stroke', 'black')
                .attr('stroke-width', 2)
                .attr('rx', 5)
                .attr('ry', 5);

            let textbox = connectionInfo.append("g").attr("transform", "translate(10,20)");

            let labelBackground = networkLayer
                .append('rect')
                .attr('class', 'label-background')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', 22)
                .attr('width', 0)
                .attr('color', 'white')
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('visibility', 'hidden');

            let label = networkLayer
                .append('text')
                .attr('dominant-baseline', 'middle')
                .attr('id', 'label')
                .attr('font-weight', 'bold');

            let mouseClicked = false;

            function convertLength(name) {
                return stringLen(name) + parseInt(name.length / 3);
            }

            function updateLabel(d) {
                label
                    .text(d.name)
                    .attr('x', d.x + 17)
                    .attr('y', d.y);

                // calculate width using length of string
                let width = convertLength(d.name) + 6;

                labelBackground
                    .attr('visibility', '')
                    .attr('width', width)
                    .attr('x', d.x + 14)
                    .attr('y', d.y - 12);
            }

            function removeLabel() {
                label.text('');
                labelBackground
                    .attr('visibility', 'hidden');
            }

            // updates the infobox displaying the names of connected characters
            function updateConnections(connections) {
                connectionInfo.attr('visibility', '');
                // connectionInfo.lower();
                textbox.html('');
                let title = textbox.append('text')
                    .text('Connections')
                    .attr('font-weight', 'bold')
                    .attr('class', 'connection-title')
                    .attr('y', 0)
                    .attr('color', 'white');
                let y = 25;
                let maxLength = convertLength('Connections') + 10;
                for (n of connections) {
                    let name = '- ' + n;
                    textbox.append('text')
                        .text(name)
                        .attr('class', 'connection-name')
                        .attr('y', y)
                        .attr('color', 'white');
                    y += 20;
                    let nameLength = convertLength(name);
                    if (nameLength > maxLength) {
                        maxLength = nameLength;
                    }
                }
                title.attr('x', (maxLength - convertLength('Connections')) / 2);

                connectionFrame
                    .attr('height', y + 10)
                    .attr('width', maxLength + 20);

                frameShadow
                    .attr('height', y + 10)
                    .attr('width', maxLength + 20);
            }

            function removeConnections() {
                connectionInfo.attr('visibility', 'hidden');
            }

            // returns all ids that are connected to the given id
            function getConnections(id) {
                let connections = appearancesMatrix[id];
                let ids = []
                for (let i = 0; i < connections.length; i++) {
                    if (connections[i] == 1 && i !== id) {
                        ids.push(i);
                    }
                }
                let names = ids.map(id => nodes[id]['name']);
                return { ids, names };
            }

            // highlights all nodes in the given id list
            function highlightConnections(ids) {
                networkLayer
                    .selectAll('circle.node')
                    .attr('fill', d => ids.includes(d.id) ? 'cornflowerblue' : d.id === 0 ? 'sienna' : 'white');
            }

            function removeHighlights() {
                networkLayer
                    .selectAll('circle.node')
                    .attr('fill', d => d.id === 0 ? 'sienna' : 'white');
            }

            function dragStart(event, d) {
                if (!event.active) {
                    label.text(d.name);
                    sim.alphaTarget(0.08).restart();
                }

                d.fx = event.x;
                d.fy = event.y;

                updateLabel(d);
                mouseClicked = true;
                let connections = getConnections(d.id);
                highlightConnections(connections['ids']);
                updateConnections(connections['names'])
            }

            function dragging(event, d) {
                d.fx = event.x;
                d.fy = event.y;
                updateLabel(d);
            }

            function dragend(event, d) {
                if (!event.active) {
                    sim.alphaTarget(0);
                    label.text('');
                }

                d.fx = null;
                d.fy = null;
                removeLabel();
                removeHighlights();
                removeConnections();
                mouseClicked = false;
            }

            function handleHover(event, d) {
                if (!mouseClicked) {
                    d3.select(this)
                        .attr('stroke-width', 2)
                        .transition().duration(200)
                        .attr('r', 13);
                    updateLabel(d3.select(this).datum());
                }
            }

            function handleMouseOut(event, d) {
                if (!mouseClicked) {
                    d3.select(this)
                        .attr('stroke-width', 1)
                        .transition().duration(200)
                        .attr('r', 10);
                    removeLabel();
                }
            }

            // ==============================
            // CHORD DIAGRAM CODE STARTS HERE
            // ==============================

            // heavy inspiration from :
            // - https://d3-graph-gallery.com/graph/chord_interactive.html
            // - https://d3-graph-gallery.com/graph/chord_axis_labels.html

            // TODO:
            // - check label distance - maybe varies per machine
            const chordSvg = d3.select('#chord');
            const foodData = await d3.csv("./data/food.csv");
            console.log(foodData);
            let counts = {};
            let chordIDs = [0, 1, 2, 5, 15, 23]; // only look at certain characters
            let chordCharacters = [
                { 'id': 0, 'name': 'Tampopo' },
                { 'id': 1, 'name': 'Goro' },
                { 'id': 2, 'name': 'Gun' },
                { 'id': 3, 'name': 'Pisuken' },
                { 'id': 4, 'name': 'Noodle-making master' },
                { 'id': 5, 'name': 'Shohei' }
            ]
            let idMap = {
                0: 0,
                1: 1,
                2: 2,
                5: 3,
                15: 4,
                23: 5
            }; // mapping the previous characterIDs to the new IDs
            let colors = ['cornflowerblue', 'tomato', 'white', 'darkolivegreen', 'blanchedalmond', 'black']
            // let colors = ['blanchedalmond', 'rgb(195,138,138)', 'darkolivegreen', 'pink', 'rgb(193,224,137)']

            const foodMatrix = new Array(6).fill(0).map(() => new Array(6).fill(0));
            console.log(foodMatrix);

            // convert to dense matrix and parse ints
            for (let link in foodData) {
                let source = parseInt(foodData[link]['id_1']);
                let target = parseInt(foodData[link]['id_2']);
                if (chordIDs.includes(source) && chordIDs.includes(target)) {
                    foodMatrix[idMap[source]][idMap[target]] += 1;
                    foodMatrix[idMap[target]][idMap[source]] += 1;

                }
            }
            console.log(foodMatrix);

            let chordDiagram = chordSvg.append('g').attr('transform', 'translate(500 300)');
            let chord = d3.chord().sortSubgroups(d3.descending).padAngle(0.05)(foodMatrix);

            let chordLabelBackground = chordSvg
                .append('rect')
                .attr('class', 'label-background')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', 22)
                .attr('width', 0)
                .attr('color', 'white')
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('visibility', 'hidden');

            let chordLabel = chordSvg
                .append('text')
                .attr('dominant-baseline', 'middle')
                .attr('id', 'label')
                .attr('font-weight', 'bold');

            function updateChordLabel(event, d) {
                let text = foodMatrix[d.source.index][d.target.index] + ' shared meals';
                let x = event.layerX;
                let y = event.layerY;
                chordLabel
                    .text(text)
                    .attr('x', x + 17)
                    .attr('y', y);

                // calculate width using length of string
                let width = convertLength(text) + 6;

                chordLabelBackground
                    .attr('visibility', '')
                    .attr('width', width)
                    .attr('x', x + 14)
                    .attr('y', y - 12);
            }

            function removeChordLabel() {
                chordLabel.text('');
                chordLabelBackground
                    .attr('visibility', 'hidden');
            }

            let backgroundCircle = chordDiagram.append('circle')
                .attr('cx', 0)
                .attr('cy', 0)
                .attr('r', 200)
                .attr('fill', 'peru');

            console.log(chord);
            let group = chordDiagram.datum(chord)
                .append('g')
                .selectAll('g')
                .data(d => d.groups)
                .enter();

            group
                .append('g')
                .append('path')
                // .style('fill', 'lightsteelblue')
                .attr('class', 'outer-band')
                .style('fill', 'darkred')
                .style('stroke', 'black')
                .attr("d", d3.arc()
                    .innerRadius(200)
                    .outerRadius(220)
                );

            chordDiagram
                .datum(chord)
                .append('g')
                .selectAll('path')
                .data(d => d)
                .enter()
                .append('path')
                .attr('d', d3.ribbon()
                    .radius(200)
                )
                .attr('class', 'ribbon')
                // .style('fill', d => colors[d.source.index])
                .style('fill', 'palegoldenrod')
                .style('stroke', 'black')
                .style('opacity', 0.8)
                .on('mouseover', mouseOverChord)
                .on('mousemove', mouseOverChord)
                .on('mouseleave', mouseLeaveChord);

            function mouseOverChord(event, d) {
                d3.select(this)
                    .attr('stroke-width', 2)
                    .style('opacity', 1);
                updateChordLabel(event, d3.select(this).datum());
            }

            function mouseLeaveChord(event, d) {
                d3.select(this)
                    .attr('stroke-width', 1)
                    .style('opacity', 0.8);
                removeChordLabel();
            }

            // Add the labels for the groups
            group
                .selectAll('.group-tick-label')
                .data(d => groupLabels(d))
                .enter()
                .append('g')
                .attr('transform', d => `rotate(${d.angle * 180 / Math.PI - 90}) translate(220,0)`)
                .append('text')
                .attr('x', 8)
                .attr('dy', '.35em')
                .attr('transform', function (d) { return d.angle > Math.PI ? 'rotate(180) translate(-16)' : null; })
                .style('text-anchor', function (d) { return d.angle > Math.PI ? 'end' : null; })
                .text(d => chordCharacters[d.id]['name'])
                .style('font-size', 20)

            function groupLabels(d) {
                return [{ id: d.index, angle: (d.startAngle + d.endAngle) / 2 }];
            }

            d3.select('#ramen').style('background-color', 'rgb(47, 71, 116)');
            d3.select('#normal').style('background-color', 'cornflowerblue');

            d3.select('#ramen').on('click', () => {
                d3.selectAll('.ribbon')
                    .style('fill', 'palegoldenrod');
                d3.selectAll('.outer-band')
                    .style('fill', 'darkred');
                backgroundCircle
                    .attr('fill', 'peru');
                d3.select('#ramen').style('background-color', 'rgb(47, 71, 116)');
                d3.select('#normal').style('background-color', 'cornflowerblue');
            })

            d3.select('#normal').on('click', () => {
                d3.selectAll('.ribbon')
                    .style('fill', d => colors[d.source.index]);
                d3.selectAll('.outer-band')
                    .style('fill', 'lightsteelblue');
                backgroundCircle
                    .attr('fill', 'white');
                d3.select('#ramen').style('background-color', 'cornflowerblue');
                d3.select('#normal').style('background-color', 'rgb(47, 71, 116)');
            })

        }
        createGraphs();

    </script>
</body>

</html>