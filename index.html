<html>

<head>
    <meta charset="UTF-8">
    <title>Tampopo project</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/marx-css/css/marx.min.css">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <main>
        <section>
            <h1>Character Connections in Tampopo</h1>
            <article>
                Tampopo is a film with a multitude of characters, both in the main story and the many
                vignettes. This graph attempts to capture the structure of Tampopo and display it in a
                way that encourages the development of new understandings of the film.
            </article>
            <article>
                Hopefully you will be able to learn things and take away something from this graph that
                was not immediately clear from a simple linear viewing of the film.
            </article>
            <article>
                Each node represents a character, and characters are connected with an edge if they appear in
                the same shot at least once during the runtime of the film. They are considered to appear in the
                same shot if they are either both visible on screen in a shot, or if they are implied to be in the
                same shot even if one or both are not visible (such as if one is in a car in the background).
            </article>
        </section>
    </main>
    <div class="center">
        <svg id="network" height="500" width="1200"></svg>
    </div>




    <script>
        // heavily inspired by Jeff R's INFO 3300 Fall 2021 notes
        const svg = d3.select('#network');
        const networkLayer = svg.append('g');
        const chartWidth = svg.attr('width');
        const chartHeight = svg.attr('height');

        const createNetwork = async function () {
            const appearances = await d3.csv("./data/appearances.csv");
            const nodes = await d3.csv("./data/characters.csv");
            let appearancesMatrix = [];

            // convert to 2d array and parse ints
            for (let i = 0; i < nodes.length; i++) {
                nodes[i]['id'] = parseInt(nodes[i]['id']);
                let curr = appearances[i];
                let row = [];
                for (let j = 0; j < nodes.length; j++) {
                    row.push(parseInt(curr[j]));
                }
                appearancesMatrix.push(row);
            }

            console.log(appearancesMatrix);
            console.log(nodes);

            let links = [];

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i; j < nodes.length; j++) {
                    if (appearancesMatrix[i][j] === 1 && i !== j) {
                        sourceID = nodes[i]['id'];
                        targetID = nodes[j]['id'];
                        link = { 'source': sourceID, 'target': targetID };
                        links.push(link);
                    }
                }
            }
            console.log(links);


            let sim = d3.forceSimulation()
                .nodes(nodes)
                .force('links', d3.forceLink().links(links).id(d => d['id'])) // force keeping nodes linked together close
                .force('repulse', d3.forceManyBody().strength(-60)) // repulsion between all nodes to space them apart
                .force('center', d3.forceCenter(chartWidth / 2., chartHeight / 2.)) // keep the whole network centered
                .on('tick', render);

            function stringLen(str) {
                const dummytext = networkLayer.append("text").attr("class", "legendtext").attr("visibility", "hidden");
                dummytext.text(str)
                let len = dummytext.node().getComputedTextLength()
                dummytext.remove()
                return len;
            }

            // TODO:
            // - is it better for the tags and nodes to go above info box or below it?
            // make the nodes and lines bigger?
            // - show names of connected nodes on drag (maybe in side graph as hard in visualization)
            // - write explanation of the graph above
            // - check connections to see if they make sense
            // - remove some characters?
            function render() {
                // draw edges
                let lines = networkLayer.selectAll('line.link').data(links)
                    .join(
                        enter => enter.append('line').attr('class', 'link').attr('stroke', 'black')
                    )
                    .attr('x1', d => d.source.x)
                    .attr('x2', d => d.target.x)
                    .attr('y1', d => d.source.y)
                    .attr('y2', d => d.target.y);

                // draw nodes
                let circles = networkLayer.selectAll('circle.node').data(nodes)
                    .join(
                        enter => enter.append('circle')
                            .attr('class', 'node')
                            .attr('stroke', 'black')
                            .attr('r', 10)
                            .attr('cx', 0)
                            .attr('cy', 0)
                            .attr('fill', d => d.id === 0 ? 'sienna' : 'white')
                            .on('mouseover', handleHover)
                            .on('mousemove', handleHover)
                            .on('mouseout', handleMouseOut)
                            .call(d3.drag().on('start', dragStart).on('drag', dragging).on('end', dragend))

                    )
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);

            }

            render();

            let connectionInfo = svg.append('g')
                .attr('class', 'connection-info')
                .attr('transform', `translate(800,60)`)
                .attr('visibility', 'hidden');

            let frameShadow = connectionInfo
                .append('rect')
                .attr('class', 'connection-shadow')
                .attr('x', 2)
                .attr('y', 2)
                .attr('height', 0)
                .attr('width', 0)
                .attr('color', 'white')
                .attr('stroke', 'black')
                .attr('stroke-width', 3)
                .attr('rx', 5)
                .attr('ry', 5);

            let connectionFrame = connectionInfo
                .append('rect')
                .attr('class', 'connection-frame')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', 0)
                .attr('width', 0)
                .attr('color', 'tomato')
                .attr('stroke', 'black')
                .attr('stroke-width', 2)
                .attr('rx', 5)
                .attr('ry', 5);

            let textbox = connectionInfo.append("g").attr("transform", "translate(10,20)");

            let labelBackground = networkLayer
                .append('rect')
                .attr('class', 'label-background')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', 22)
                .attr('width', 0)
                .attr('color', 'white')
                .attr('stroke', 'black')
                .attr('stroke-width', 1)
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('visibility', 'hidden');

            let label = networkLayer
                .append('text')
                .attr('dominant-baseline', 'middle')
                .attr('id', 'label')
                .attr('font-weight', 'bold');

            let mouseClicked = false;

            function convertLength(name) {
                return stringLen(name) + parseInt(name.length / 3);
            }

            function updateLabel(d) {
                label
                    .text(d.name)
                    .attr('x', d.x + 17)
                    .attr('y', d.y);

                // calculate width using length of string
                let width = convertLength(d.name) + 6;

                labelBackground
                    .attr('visibility', '')
                    .attr('width', width)
                    .attr('x', d.x + 14)
                    .attr('y', d.y - 12);
            }

            function removeLabel() {
                label.text('');
                labelBackground
                    .attr('visibility', 'hidden');
            }

            // updates the infobox displaying the names of connected characters
            function updateConnections(connections) {
                connectionInfo.attr('visibility', '');
                // connectionInfo.lower();
                textbox.html('');
                let title = textbox.append('text')
                    .text('Connections')
                    .attr('font-weight', 'bold')
                    .attr('class', 'connection-title')
                    .attr('y', 0)
                    .attr('color', 'white');
                let y = 25;
                let maxLength = convertLength('Connections') + 10;
                for (n of connections) {
                    let name = '- ' + n;
                    textbox.append('text')
                        .text(name)
                        .attr('class', 'connection-name')
                        .attr('y', y)
                        .attr('color', 'white');
                    y += 20;
                    let nameLength = convertLength(name);
                    if (nameLength > maxLength) {
                        maxLength = nameLength;
                    }
                }
                title.attr('x', (maxLength - convertLength('Connections')) / 2);

                connectionFrame
                    .attr('height', y + 10)
                    .attr('width', maxLength + 20);

                frameShadow
                    .attr('height', y + 10)
                    .attr('width', maxLength + 20);
            }

            function removeConnections() {
                connectionInfo.attr('visibility', 'hidden');
            }

            // returns all ids that are connected to the given id
            function getConnections(id) {
                let connections = appearancesMatrix[id];
                let ids = []
                for (let i = 0; i < connections.length; i++) {
                    if (connections[i] == 1 && i !== id) {
                        ids.push(i);
                    }
                }
                let names = ids.map(id => nodes[id]['name']);
                return { ids, names };
            }

            // highlights all nodes in the given id list
            function highlightConnections(ids) {
                networkLayer
                    .selectAll('circle.node')
                    .attr('fill', d => ids.includes(d.id) ? 'cornflowerblue' : d.id === 0 ? 'sienna' : 'white');
            }

            function removeHighlights() {
                networkLayer
                    .selectAll('circle.node')
                    .attr('fill', d => d.id === 0 ? 'sienna' : 'white');
            }

            function dragStart(event, d) {
                if (!event.active) {
                    label.text(d.name);
                    sim.alphaTarget(0.08).restart();
                }

                d.fx = event.x;
                d.fy = event.y;

                updateLabel(d);
                mouseClicked = true;
                let connections = getConnections(d.id);
                highlightConnections(connections['ids']);
                updateConnections(connections['names'])
            }

            function dragging(event, d) {
                d.fx = event.x;
                d.fy = event.y;
                updateLabel(d);
            }

            function dragend(event, d) {
                if (!event.active) {
                    sim.alphaTarget(0);
                    label.text('');
                }

                d.fx = null;
                d.fy = null;
                removeLabel();
                removeHighlights();
                removeConnections();
                mouseClicked = false;
            }

            function handleHover(event, d) {
                if (!mouseClicked) {
                    d3.select(this)
                        .attr('stroke-width', 2)
                        .transition().duration(200)
                        .attr('r', 13);
                    updateLabel(d3.select(this).datum());
                }
            }

            function handleMouseOut(event, d) {
                if (!mouseClicked) {
                    d3.select(this)
                        .attr('stroke-width', 1)
                        .transition().duration(200)
                        .attr('r', 10);
                    removeLabel();
                }
            }
        }
        createNetwork();

    </script>
</body>

</html>